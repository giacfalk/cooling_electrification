# East
I2=stack(sin((d2)*degrees_to_radians)/degrees_to_radians)
values(I2) <- ifelse(values(I2<0), 0, values(I2))
I2
# South
I3=stack(sin((d3)*degrees_to_radians)/degrees_to_radians)
values(I3) <- ifelse(values(I3), 0, values(I3))
I3
# West
I4=stack(sin((d4)*degrees_to_radians)/degrees_to_radians)
values(I4) <- ifelse(values(I4<0), 0, values(I4))
I4
d3
sin((d3)*degrees_to_radians
)
stack(sin((d3)*degrees_to_radians)/degrees_to_radians)
# North
I1=stack(sin(((d1))*degrees_to_radians)/degrees_to_radians)
values(I1) <- ifelse(values(I1<0), 0, values(I1))
# East
I2=stack(sin((d2)*degrees_to_radians)/degrees_to_radians)
values(I2) <- ifelse(values(I2<0), 0, values(I2))
# South
I3=stack(sin((d3)*degrees_to_radians)/degrees_to_radians)
values(I3) <- ifelse(values(I3)<0, 0, values(I3))
# West
I4=stack(sin((d4)*degrees_to_radians)/degrees_to_radians)
values(I4) <- ifelse(values(I4<0), 0, values(I4))
I3
I4
I2
I1
Iv <- projectRaster(Iv, I1)
sol_rad_1 <- stack(Iv * I1)
sol_rad_2 <- stack(Iv * I2)
sol_rad_3 <- stack(Iv * I3)
sol_rad_4 <- stack(Iv * I4)
sol_rad_2 <- stack(Iv * I2)
sol_rad_2
sol_rad_1
sol_rad_3
sol_rad_1
sol_rad_3
sol_rad_4
angle_diff <- function(theta1, theta2){
theta <- abs(theta1 - theta2) %% 360
return(ifelse(theta > 180, 360 - theta, theta))
}
d1 <- calc(azimuth, fun=function(X){ angle_diff(180, X)})
d2 <- calc(azimuth, fun=function(X){ angle_diff(270, X)})
d3 <- calc(azimuth, fun=function(X){ angle_diff(0, X)})
d4 <- calc(azimuth, fun=function(X){ angle_diff(90, X)})
# North
I1=stack(sin(((d1))*degrees_to_radians)/degrees_to_radians)
values(I1) <- ifelse(values(I1<0), 0, values(I1))
# East
I2=stack(sin((d2)*degrees_to_radians)/degrees_to_radians)
values(I2) <- ifelse(values(I2<0), 0, values(I2))
# South
I3=stack(sin((d3)*degrees_to_radians)/degrees_to_radians)
values(I3) <- ifelse(values(I3)<0, 0, values(I3))
# West
I4=stack(sin((d4)*degrees_to_radians)/degrees_to_radians)
values(I4) <- ifelse(values(I4<0), 0, values(I4))
#We now multiply the 'solar intensity on the horizontal' data by the conversion factors calculated above to get data for 'solar intensity on each face of the house'
Iv <- projectRaster(Iv, I1)
sol_rad_1 <- stack(Iv * I1)
sol_rad_2 <- stack(Iv * I2)
sol_rad_3 <- stack(Iv * I3)
sol_rad_4 <- stack(Iv * I4)
sol_rad_4
sol_rad_3
sol_rad_2
sol_rad_1
plot(sol_rad_1[[1]])
plot(sol_rad_3[[1]])
plot(sol_rad_4[[1]])
plot(sol_rad_1[[1]])
I1
I3
d1
d2
d3
d4
d1 <- calc(azimuth, fun=function(X){ angle_diff(180, X)})
d2 <- calc(azimuth, fun=function(X){ angle_diff(270, X)})
d3 <- calc(azimuth, fun=function(X){ angle_diff(360, X)})
d4 <- calc(azimuth, fun=function(X){ angle_diff(90, X)})
d1
d2
d3
d4
d1
d3
d2
d4
# North
I1=stack(sin(((d1))*degrees_to_radians)/degrees_to_radians)
values(I1) <- ifelse(values(I1<0), 0, values(I1))
# East
I2=stack(sin((d2)*degrees_to_radians)/degrees_to_radians)
values(I2) <- ifelse(values(I2<0), 0, values(I2))
# South
I3=stack(sin((d3)*degrees_to_radians)/degrees_to_radians)
values(I3) <- ifelse(values(I3)<0, 0, values(I3))
# West
I4=stack(sin((d4)*degrees_to_radians)/degrees_to_radians)
values(I4) <- ifelse(values(I4<0), 0, values(I4))
I1
I2
I3
I1
I4
#We now multiply the 'solar intensity on the horizontal' data by the conversion factors calculated above to get data for 'solar intensity on each face of the house'
Iv <- projectRaster(Iv, I1)
sol_rad_1 <- stack(Iv * I1)
sol_rad_2 <- stack(Iv * I2)
sol_rad_3 <- stack(Iv * I3)
sol_rad_4 <- stack(Iv * I4)
#We then convert those intensities to the powers and energies that we are really interested in. To go from the intensity of the light falling on the wall (W/m²) to the power of the sunlight hitting the windows, we multiply the intensity by the window areas. Only a fraction of the sunlight that hits the window will pass through it. The proportion of the sunlight that will pass through the window is defined by the solar heat gain coefficient. It is a property of the window itself. So to get the solar power passing through the windows, we just multiply the values for the power hitting the windows by the solar heat gain coefficient.
m2_windows_urban <- 15
m2_windows_rural <- 25
k_solar_heat_gain  <- 0.4
kw_imh_1 <- stack(sol_rad_1*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_2 <- stack(sol_rad_2*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_3 <- stack(sol_rad_3*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_4 <- stack(sol_rad_4*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_4
kw_imh_3
kw_imh_2
kw_imh_1
#We now multiply the 'solar intensity on the horizontal' data by the conversion factors calculated above to get data for 'solar intensity on each face of the house'
Iv <- projectRaster(Iv, I1)
sol_rad_1 <- stack(Iv * I1)
sol_rad_2 <- stack(Iv * I2)
sol_rad_3 <- stack(Iv * I3)
sol_rad_4 <- stack(Iv * I4)
#We then convert those intensities to the powers and energies that we are really interested in. To go from the intensity of the light falling on the wall (W/m²) to the power of the sunlight hitting the windows, we multiply the intensity by the window areas. Only a fraction of the sunlight that hits the window will pass through it. The proportion of the sunlight that will pass through the window is defined by the solar heat gain coefficient. It is a property of the window itself. So to get the solar power passing through the windows, we just multiply the values for the power hitting the windows by the solar heat gain coefficient.
m2_windows_urban <- 15
m2_windows_rural <- 25
k_solar_heat_gain  <- 0.4
kw_imh_1 <- stack(sol_rad_1*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_2 <- stack(sol_rad_2*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_3 <- stack(sol_rad_3*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_4 <- stack(sol_rad_4*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_3
kw_imh_4
kw_imh_2
kw_imh_1
#Finally we need to integrate the powers with respect to time to get the energies. The plot below shows the solar energy entering the house through the windows on each face of a building each day
# average joule from the window every hour of the day of month m at location i
j_imh_1 <- stack(3600000 * kw_imh_1)
j_imh_2 <- stack(3600000 * kw_imh_2)
j_imh_3 <- stack(3600000 * kw_imh_3)
j_imh_4 <- stack(3600000 * kw_imh_4)
j_imh_4
j_imh_3
j_imh_2
j_imh_1
j_imh_2
j_imh_3
j_imh_4
plot(I1[[1]])
plot(I3[[1]])
plot(I3[[6]])
plot(I1[[6]])
j_imh_2
sol_rad_1
m2_windows_urban
k_solar_heat_gain
kw_imh_2
kw_imh_1
kw_imh_3
kw_imh_4
kw_imh_3
CC_urban*cooling_ton_to_kw*kw_to_j_per_hour
# when keeping cold, the compressor is on every hour the fraction j_imh / j_per_hour
compressor_share_time_on_urban <- stack(j_imh_2 / CC_urban*cooling_ton_to_kw*kw_to_j_per_hour) # j/hour / j removed in one hour
compressor_share_time_on_urban
plot(compressor_share_time_on_urban)
values(compressor_share_time_on_urban) <- ifelse(values(compressor_share_time_on_urban)>1, 1, values(compressor_share_time_on_urban))
compressor_share_time_on_urban
plot(compressor_share_time_on_urban[[1]])
j_imh_2
37212716/CC_urban*cooling_ton_to_kw*kw_to_j_per_hour
CC_urban*cooling_ton_to_kw*kw_to_j_per_hour
37212716/13504704
# when keeping cold, the compressor is on every hour the fraction j_imh / j_per_hour
compressor_share_time_on_urban <- stack(j_imh_2 / (CC_urban*cooling_ton_to_kw*kw_to_j_per_hour)) # j/hour / j removed in one hour
values(compressor_share_time_on_urban) <- ifelse(values(compressor_share_time_on_urban)>1, 1, values(compressor_share_time_on_urban))
compressor_share_time_on_urban
plot(compressor_share_time_on_urban[[1]])
plot(compressor_share_time_on_urban[[6]])
plot(compressor_share_time_on_urban[[4]])
plot(compressor_share_time_on_urban[[3]])
compressor_share_time_on_rural <- stack(j_imh_2 / (CC_rural*cooling_ton_to_kw*kw_to_j_per_hour)) # j/hour / j removed in one hour
values(compressor_share_time_on_rural) <- ifelse(values(compressor_share_time_on_rural)>1, 1, values(compressor_share_time_on_rural))
plot(compressor_share_time_on_rural[[6]])
plot(compressor_share_time_on_rural[[3]])
m2_windows_urban <- 12.5
m2_windows_rural <- 22.5
k_solar_heat_gain  <- 0.4
kw_imh_1 <- stack(sol_rad_1*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_2 <- stack(sol_rad_2*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_3 <- stack(sol_rad_3*m2_windows_urban*k_solar_heat_gain/1000)
kw_imh_4 <- stack(sol_rad_4*m2_windows_urban*k_solar_heat_gain/1000)
#Finally we need to integrate the powers with respect to time to get the energies. The plot below shows the solar energy entering the house through the windows on each face of a building each day
# average joule from the window every hour of the day of month m at location i
j_imh_1 <- stack(3600000 * kw_imh_1)
j_imh_2 <- stack(3600000 * kw_imh_2)
j_imh_3 <- stack(3600000 * kw_imh_3)
j_imh_4 <- stack(3600000 * kw_imh_4)
# when keeping cold, the compressor is on every hour the fraction j_imh / j_per_hour
compressor_share_time_on_urban <- stack(j_imh_2 / (CC_urban*cooling_ton_to_kw*kw_to_j_per_hour)) # j/hour / j removed in one hour
values(compressor_share_time_on_urban) <- ifelse(values(compressor_share_time_on_urban)>1, 1, values(compressor_share_time_on_urban))
compressor_share_time_on_rural <- stack(j_imh_2 / (CC_rural*cooling_ton_to_kw*kw_to_j_per_hour)) # j/hour / j removed in one hour
values(compressor_share_time_on_rural) <- ifelse(values(compressor_share_time_on_rural)>1, 1, values(compressor_share_time_on_rural))
ò.
plot(compressor_share_time_on_rural[[6]])
plot(compressor_share_time_on_rural[[1]])
plot(compressor_share_time_on_rural[[3]])
plot(compressor_share_time_on_rural[[9]])
plot(compressor_share_time_on_rural[[12]])
plot(compressor_share_time_on_rural[[9]])
#Wrapper
library(tidyverse)
library(reshape2)
library(lubridate)
library(raster)
library(sf)
library(exactextractr)
library(countrycode)
library(rasterVis)
library(maps)
library(mapdata)
library(maptools)
library(rgdal)
library(gglorenz)
library(fasterize)
library(viridis)
library(data.table)
library(oce)
library(osc)
library(lutz)
library(suncalc)
setwd('D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA')
# parameters
base_temp = 26
########
# Building parameters
avg_house_area_urban <- 60 #sq m.
avg_house_area_rural <- 100 #sq m.
share_house_cooled_urban = 0.80
share_house_cooled_rural = 0.35
m2_windows_urban <- 12.5
m2_windows_rural <- 22.5
k_solar_heat_gain  <- 0.4
avg_house_volume_urban <- avg_house_area_urban * 2.5 * share_house_cooled_urban #m3
avg_house_volume_rural <- avg_house_area_rural * 3 * share_house_cooled_rural #m3
# AC parameters
m2_per_Cton = 45
CC_urban = avg_house_area_urban*share_house_cooled_urban/m2_per_Cton
CC_rural = avg_house_area_rural*share_house_cooled_rural/m2_per_Cton
cooling_ton_to_kw = 3.51685
kw_to_j_per_hour = 3600000
m3toliters = 1000
EER_rural = 2.2
EER_urban = 2.9
# Fan parameters
Fan_power = 70
min_hrs_permonth_fan_use = 0
max_hrs_permonth_fan_use = 480
# process the CDD and noaccess data (default base T)
source("code/data_process.R", echo=T)
# process the CDD and noaccess data (to produce variants with different base T)
#source("code/data_process_2.R", echo=T)
# generate Figures 1-2-3
#source("code/figures123.R", echo=T)
# calculate heat entering houses from windows
source("code/window_heat_gain", echo=T)
# calculate heat entering houses from windows
source("code/window_heat_gain.R", echo=T)
#calculate kwh to meet CDDs #
#
# urbrur = raster('GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K_V2_0.tif')
#
# template <- raster('D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Anteneh/nodatamask_1.ASC')
#
# template_pol <- rasterToPolygons(template)
# template_pol = st_as_sf(template_pol)
# st_crs(template_pol)<-4326
#
# template_pol$urbrur = exactextractr::exact_extract(urbrur, template_pol, fun="mean")
#
# template_pol$urbrur = ifelse(template_pol$urbrur>11.5, 1, 0)
#
# library(fasterize)
# urbrur <- fasterize(template_pol, template, field="urbrur", fun="first")
#
# plot(urbrur)
# crs(urbrur)<-"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
#
# writeRaster(urbrur, "D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA/urbrur.tif", overwrite=T)
#
urbrur<-raster("D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA/urbrur.tif")
# calculate average number of people in each household based on country and urban/rural
hhsize <- readxl::read_xlsx("D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA/csvs/population_division_UN_Houseshold_Size_and_Composition_2019.xlsx", sheet="UN HH Size and Composition 2019")
hhsize <- hhsize %>% group_by(`Country or area`) %>% slice(which.max(as.Date(`Reference date (dd/mm/yyyy)`, '%d/%m/%Y'))) %>% ungroup()
hhsize$ISO = countrycode::countrycode(hhsize$`Country or area`, 'country.name', 'iso3c')
hhsize = hhsize %>% dplyr::select(ISO, `Average household size (number of members)`)
isos = unique(world$GID_0)
diff <-setdiff(isos, hhsize$ISO)
more.rows <- data.frame(ISO=diff, `Average household size (number of members)`=NA, stringsAsFactors=F)
colnames(more.rows)[2] <- "Average household size (number of members)"
hhsize<-bind_rows(hhsize, more.rows)
hhsize$`Average household size (number of members)` <- ifelse(hhsize$`Average household size (number of members)` =="..", NA, hhsize$`Average household size (number of members)`)
hhsize$`Average household size (number of members)`=as.numeric(hhsize$`Average household size (number of members)`)
hhsize$`Average household size (number of members)` <- ifelse(is.na(hhsize$`Average household size (number of members)`), mean(hhsize$`Average household size (number of members)`, na.rm=TRUE), hhsize$`Average household size (number of members)`)
world = merge(world, hhsize, by.x="GID_0", by.y="ISO")
world$hhsize = world$`Average household size (number of members)`
Sys.sleep(1.5)
hhsize_raster<-fasterize(world, overlay_current[[1]], "hhsize", fun="first")
hhsize_raster <- projectRaster(hhsize_raster, urbrur)
values(hhsize_raster) <- ifelse(values(urbrur)==1, values(hhsize_raster) * 0.75, values(hhsize_raster) * 1.25)
hhsize_raster <- projectRaster(hhsize_raster, noacc18)
HHs_raster = noacc18/hhsize_raster
###########
crs(CDDs) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# loop over the three climate scenarios
scenarios <- c(overlay_current, overlay_245, overlay_370)
all_results=list()
k=1
for (scenario_climate in scenarios){
urbrur<-raster("D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA/urbrur.tif")
mean_CDDs <- calc(scenario_climate, fun = mean, na.rm = T)
hoursheatday_im <- (scenario_climate/mean_CDDs)*6
hoursheatday_im <- stack(hoursheatday_im)
hoursheatday_im = projectRaster(hoursheatday_im, scenario_climate)
hoursheatday_im = stack(hoursheatday_im)
values(hoursheatday_im) = ifelse(values(hoursheatday_im)>10, 10, values(hoursheatday_im))
values(hoursheatday_im) = ifelse(values(hoursheatday_im)<0, 0, values(hoursheatday_im))
DeltaT_im = scenario_climate
Q_im = list()
urbrur = projectRaster(urbrur, DeltaT_im, method = "ngb")
Q_im <- overlay(urbrur, DeltaT_im, fun=Vectorize(function(x,y){
y[x==0] <- 29*(avg_house_volume_rural* m3toliters /24)*y
y[x==1] <- 29*(avg_house_volume_urban * m3toliters /24)*y
return(y)
}))
Q_im = stack(Q_im)
AChours_im = list()
urbrur = projectRaster(urbrur, Q_im, method = "ngb")
# hours of peak load of compressor in each month i
AChours_im= overlay(urbrur, Q_im, fun=Vectorize(function(x,y){
y[x==1] = (y/(CC_urban*cooling_ton_to_kw*kw_to_j_per_hour))
y[x==0] = (y/(CC_rural*cooling_ton_to_kw*kw_to_j_per_hour))
return(y)
}))
AChours_im = stack(AChours_im)
ACconsumption_im_hh = list()
AChours_im = projectRaster(AChours_im, urbrur)
values(AChours_im) = ifelse(values(AChours_im)<0, 0, values(AChours_im))
# compressor runs 100% of the time when bringing temperature to desired temperature
# compressor runs x% of the time when keeping temperature steady (see window_heat_gain.R)
ACconsumption_im_hh = overlay(urbrur, AChours_im, hoursheatday_im, compressor_share_time_on_urban, compressor_share_time_on_rural, fun=Vectorize(function(x,y, z, k, l){
y[x==1] = (((CC_urban*cooling_ton_to_kw) / EER_urban) * (y)) + (((CC_urban*cooling_ton_to_kw) / EER_urban) * (z) * k)
y[x==0] = (((CC_rural*cooling_ton_to_kw) / EER_rural) * (y)) +  (((CC_rural*cooling_ton_to_kw) / EER_rural) * (z) * l)
return(y)
}))
ACconsumption_im_hh = stack(ACconsumption_im_hh)*30
ACconsumption_i_hh <- calc(ACconsumption_im_hh, fun = sum, na.rm = T)
ACconsumption_i = ACconsumption_i_hh * HHs_raster
###
# latent AC demand from HHs without electricity access
sum(values(ACconsumption_i), na.rm = T)/1000000000
###
mean_CDDs <- calc(scenario_climate, fun = sum, na.rm = T)
hoursfanuse_im <- (scenario_climate/mean_CDDs)* (max_hrs_permonth_fan_use - min_hrs_permonth_fan_use) + min_hrs_permonth_fan_use
FANconsumption_im_hh = Fan_power*hoursfanuse_im/1000
FANconsumption_i_hh <- calc(FANconsumption_im_hh, fun = sum, na.rm = T)
FANconsumption_i = FANconsumption_i_hh * HHs_raster
sum(values(FANconsumption_i), na.rm = T)/1000000000
##
# extract sum by group of ISO raster
world$FANconsumption = exact_extract(FANconsumption_i, world, 'sum')
world$ACconsumption = exact_extract(ACconsumption_i, world, 'sum')
world$TOTconsumption = world$FANconsumption + world$ACconsumption
world = st_as_sf(world)
#TWh
sum(world$ACconsumption, na.rm = T) / 1000000000
sum(world$FANconsumption, na.rm = T) / 1000000000
sum(world$TOTconsumption, na.rm = T) / 1000000000
# today about 2000 TWh of AC consumption worldwide: https://www.iea.org/reports/the-future-of-cooling
#########
# Simulate penetration of technologies based on CDDs, wealth, and urb/rur
##########
pop_urban<-overlay(noacc18, urbrur, fun=function(x,y){
x[y==0]<-NA
return(x)
})
pop_rural<-overlay(noacc18, urbrur, fun=function(x,y){
x[y==1]<-NA
return(x)
})
# wealth quintiles (sub-national data); where unavailable use a fixed share of urb/rur population
wealth <- read_sf("D:/OneDrive - FONDAZIONE ENI ENRICO MATTEI/Current papers/Latent demand air cooling/cooling_electricity_SSA/dhs/sdr_exports.gdb")
wealth <- dplyr::select(wealth, 30:34, Shape)
q1<-fasterize(wealth, overlay_current[[1]], "HCWIXQPLOW", fun="first")
q2<-fasterize(wealth, overlay_current[[1]], "HCWIXQP2ND", fun="first")
q3<-fasterize(wealth, overlay_current[[1]], "HCWIXQPMID", fun="first")
q4<-fasterize(wealth, overlay_current[[1]], "HCWIXQP4TH", fun="first")
q5<-fasterize(wealth, overlay_current[[1]], "HCWIXQPHGH", fun="first")
# # Scenario 1: AC to 60% wealthiest urban households and 20% wealthiest households above in rural
AC_demanding_pop_S1 <- merge(pop_urban/hhsize_raster*(q3+q4+q5)/100, pop_rural/hhsize_raster*(q5)/100)
values(AC_demanding_pop_S1) <- ifelse(values(pop_urban)>0 & is.na(values(q3)), values(pop_urban/hhsize_raster*0.6), values(AC_demanding_pop_S1))
values(AC_demanding_pop_S1) <- ifelse(values(pop_rural)>0 & is.na(values(q3)), values(pop_rural/hhsize_raster*0.2), values(AC_demanding_pop_S1))
FAN_demanding_pop_S1 <- noacc18/hhsize_raster - AC_demanding_pop_S1
AC_demanding_share_S1 <- AC_demanding_pop_S1 / (AC_demanding_pop_S1 + FAN_demanding_pop_S1)
FAN_demanding_share_S1 <- FAN_demanding_pop_S1 / (AC_demanding_pop_S1 + FAN_demanding_pop_S1)
kwh_S1 = FANconsumption_i * FAN_demanding_share_S1 + ACconsumption_i * AC_demanding_share_S1
world$kwh_S1 = exact_extract(kwh_S1, world, 'sum')
# # Scenario 2: AC to 100% urban households and 40% wealthiest households in rural
AC_demanding_pop_S2 <- merge(pop_urban/hhsize_raster*(q1+q2+q3+q4+q5)/100, pop_rural/hhsize_raster*(q4+q5)/100)
values(AC_demanding_pop_S2) <- ifelse(values(pop_urban)>0 & is.na(values(q3)), values(pop_urban/hhsize_raster*1), values(AC_demanding_pop_S2))
values(AC_demanding_pop_S2) <- ifelse(values(pop_rural)>0 & is.na(values(q3)), values(pop_rural/hhsize_raster*0.4), values(AC_demanding_pop_S2))
FAN_demanding_pop_S2 <- noacc18/hhsize_raster - AC_demanding_pop_S2
AC_demanding_share_S2 <- AC_demanding_pop_S2 / (AC_demanding_pop_S2 + FAN_demanding_pop_S2)
FAN_demanding_share_S2 <- FAN_demanding_pop_S2 / (AC_demanding_pop_S2 + FAN_demanding_pop_S2)
kwh_S2 = FANconsumption_i * FAN_demanding_share_S2 + ACconsumption_i * AC_demanding_share_S2
world$kwh_S2 = exact_extract(kwh_S2, world, 'sum')
# # Scenario 3 (benchmark): all AC
AC_demanding_pop_S3 <- merge(pop_urban/hhsize_raster*(q1+q2+q3+q4+q5)/100, pop_rural/hhsize_raster*(q1+q2+q3+q4+q5)/100)
values(AC_demanding_pop_S3) <- ifelse(values(pop_urban)>0 & is.na(values(q3)), values(pop_urban/hhsize_raster*1), values(AC_demanding_pop_S3))
values(AC_demanding_pop_S3) <- ifelse(values(pop_rural)>0 & is.na(values(q3)), values(pop_rural/hhsize_raster*1), values(AC_demanding_pop_S3))
FAN_demanding_pop_S3 <- noacc18/hhsize_raster - AC_demanding_pop_S3
AC_demanding_share_S3 <- AC_demanding_pop_S3 / (AC_demanding_pop_S3 + FAN_demanding_pop_S3)
FAN_demanding_share_S3 <- FAN_demanding_pop_S3 / (AC_demanding_pop_S3 + FAN_demanding_pop_S3)
kwh_S3 = FANconsumption_i * FAN_demanding_share_S3 + ACconsumption_i * AC_demanding_share_S3
world$kwh_S3 = exact_extract(kwh_S3, world, 'sum')
# # Scenario 4 (benchmark): all fan
AC_demanding_pop_S4 <- merge(pop_urban/hhsize_raster*(0)/100, pop_rural/hhsize_raster*(0)/100)
values(AC_demanding_pop_S4) <- ifelse(values(pop_urban)>0 & is.na(values(q3)), values(pop_urban/hhsize_raster*0), values(AC_demanding_pop_S4))
values(AC_demanding_pop_S4) <- ifelse(values(pop_rural)>0 & is.na(values(q3)), values(pop_rural/hhsize_raster*0), values(AC_demanding_pop_S4))
FAN_demanding_pop_S4 <- noacc18/hhsize_raster - AC_demanding_pop_S4
AC_demanding_share_S4 <- AC_demanding_pop_S4 / (AC_demanding_pop_S4 + FAN_demanding_pop_S4)
FAN_demanding_share_S4 <- FAN_demanding_pop_S4 / (AC_demanding_pop_S4 + FAN_demanding_pop_S4)
kwh_S4 = FANconsumption_i * FAN_demanding_share_S4 + ACconsumption_i * AC_demanding_share_S4
world$kwh_S4 = exact_extract(kwh_S4, world, 'sum')
# melt by scenario
world_out = gather(world, "scenario", "kwh", kwh_S1, kwh_S2, kwh_S3, kwh_S4)
world_out$geometry=NULL
all_results[[k]] = world_out
k = k+1
gc()
}
world = rbindlist(all_results, idcol = T)
world$id = world$.id
world$id = ifelse(world$id==1, "Baseline", ifelse(world$id==2, "RCP245", "RCP370"))
world = subset(world, world$kwh!=0)
countries_without = world
countries_without$geometry=NULL
summary_electricity <- countries_without %>% group_by(scenario, id) %>% summarise(twh = sum(kwh, na.rm = T)/1000000000)
write.csv(summary_electricity, paste0("summary_power_consumpion_", base_temp, "_", EER_urban, "_", EER_rural, ".csv"))
world_plot = world %>% group_by(id, scenario, continent) %>% mutate(kwh=sum(kwh, na.rm = T))
# plot
kwh_country = ggplot() +
theme_classic()+
geom_bar(data = world_plot[which(world_plot$kwh>1000000),], aes(x = continent , y = kwh/1000000000, fill=id), stat = "sum", position = "dodge", show.legend=c(size=FALSE)) +
theme(axis.text.x = element_text(angle = 90, size=8), plot.title = element_text(hjust = 0.5))+
scale_fill_brewer(name="Scenario", palette = "Set1")+
ylab("Latent power demand for air cooling \nfrom households without electricty")+
xlab("Region")+
ggtitle("Yearly electricity consumption (TWh)")+
facet_wrap(~ scenario, ncol=2)
ggsave(paste0("kwh_region_", base_temp, ".png"), kwh_country, device="png")
write.csv(world_plot, paste0("power_consumpion_", base_temp, "_", EER_urban, "_", EER_rural, ".csv"))
# world$noacc18 = exact_extract(noacc18, world, 'sum')
# world$kwhcapita = world$kwh/world$noacc18
#
# kwh_map = ggplot() +
#   theme_classic()+
#   geom_sf(data = world, aes(fill = kwh/noacc18)) +
#   theme(axis.text.x = element_text(angle = 90, size=8), plot.title = element_text(hjust = 0.5))+
#   scale_fill_viridis_b(name = "kWh/person without electricity access", trans="log")+
#   #ggtitle("")+
#   ylab("Latitude")+
#   xlab("Longitude")+
#   facet_wrap(~ scenario, ncol=2)
#ggsave("kwh_map.png", kwh_map, device="png")
# estimate co2 emissions
source("code/emissions.R", echo=T)
# Plot results
co2_region = ggplot() +
theme_gray()+
geom_bar(data = world_plot[which(world_plot$co2>1000000000),], aes(x = continent , y = co2/1000000000000, fill=id), stat="sum", position = "dodge", show.legend=c(size=FALSE)) +
theme(axis.text.x = element_text(angle = 90, size=8), plot.title = element_text(hjust = 0.5))+
scale_fill_brewer(name="Scenario", palette = "Set1")+
ylab("Potential emissions for air cooling \nfrom households without electricty")+
xlab("Region")+
ggtitle("Yearly CO2 emissions (Mt CO2)")+
facet_wrap(~ scenario, ncol=2)
ggsave(paste0("co2_region_", base_temp, ".png"), co2_region, device="png")
# Plot results
co2_region = ggplot() +
geom_bar(data = world_plot[which(world_plot$co2>1000000000),], aes(x = continent , y = co2/1000000000000, fill=id), stat="sum", position = "dodge", show.legend=c(size=FALSE)) +
theme(axis.text.x = element_text(angle = 90, size=8), plot.title = element_text(hjust = 0.5))+
scale_fill_brewer(name="Scenario", palette = "Set1")+
ylab("Potential emissions for air cooling \nfrom households without electricty")+
xlab("Region")+
ggtitle("Yearly CO2 emissions (Mt CO2)")+
facet_wrap(~ scenario, ncol=2)
ggsave(paste0("co2_region_", base_temp, ".png"), co2_region, device="png")
